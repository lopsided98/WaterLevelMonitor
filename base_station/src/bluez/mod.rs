// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

#![allow(dead_code)]
use dbus as dbus;
use dbus::arg;
use dbus::tree;

pub trait AgentManager1 {
    type Err;
    fn register_agent(&self, agent: dbus::Path, capability: &str) -> Result<(), Self::Err>;
    fn unregister_agent(&self, agent: dbus::Path) -> Result<(), Self::Err>;
    fn request_default_agent(&self, agent: dbus::Path) -> Result<(), Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> AgentManager1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn register_agent(&self, agent: dbus::Path, capability: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.AgentManager1".into(), &"RegisterAgent".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(agent);
            i.append(capability);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unregister_agent(&self, agent: dbus::Path) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.AgentManager1".into(), &"UnregisterAgent".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(agent);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn request_default_agent(&self, agent: dbus::Path) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.AgentManager1".into(), &"RequestDefaultAgent".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(agent);
        })?;
        m.as_result()?;
        Ok(())
    }
}

pub fn agent_manager1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: AgentManager1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.AgentManager1", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let agent: dbus::Path = i.read()?;
        let capability: &str = i.read()?;
        let d = fclone(minfo);
        d.register_agent(agent, capability)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterAgent", Default::default(), h);
    let m = m.in_arg(("agent", "o"));
    let m = m.in_arg(("capability", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let agent: dbus::Path = i.read()?;
        let d = fclone(minfo);
        d.unregister_agent(agent)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnregisterAgent", Default::default(), h);
    let m = m.in_arg(("agent", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let agent: dbus::Path = i.read()?;
        let d = fclone(minfo);
        d.request_default_agent(agent)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RequestDefaultAgent", Default::default(), h);
    let m = m.in_arg(("agent", "o"));
    let i = i.add_m(m);
    i
}

pub trait ProfileManager1 {
    type Err;
    fn register_profile(&self, profile: dbus::Path, uuid: &str, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err>;
    fn unregister_profile(&self, profile: dbus::Path) -> Result<(), Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> ProfileManager1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn register_profile(&self, profile: dbus::Path, uuid: &str, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.ProfileManager1".into(), &"RegisterProfile".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(profile);
            i.append(uuid);
            i.append(options);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unregister_profile(&self, profile: dbus::Path) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.ProfileManager1".into(), &"UnregisterProfile".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(profile);
        })?;
        m.as_result()?;
        Ok(())
    }
}

pub fn profile_manager1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: ProfileManager1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.ProfileManager1", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let profile: dbus::Path = i.read()?;
        let uuid: &str = i.read()?;
        let options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        d.register_profile(profile, uuid, options)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterProfile", Default::default(), h);
    let m = m.in_arg(("profile", "o"));
    let m = m.in_arg(("UUID", "s"));
    let m = m.in_arg(("options", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let profile: dbus::Path = i.read()?;
        let d = fclone(minfo);
        d.unregister_profile(profile)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnregisterProfile", Default::default(), h);
    let m = m.in_arg(("profile", "o"));
    let i = i.add_m(m);
    i
}

pub trait Adapter1 {
    type Err;
    fn start_discovery(&self) -> Result<(), Self::Err>;
    fn set_discovery_filter(&self, properties: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err>;
    fn stop_discovery(&self) -> Result<(), Self::Err>;
    fn remove_device(&self, device: dbus::Path) -> Result<(), Self::Err>;
    fn get_discovery_filters(&self) -> Result<Vec<String>, Self::Err>;
    fn get_address(&self) -> Result<String, Self::Err>;
    fn get_address_type(&self) -> Result<String, Self::Err>;
    fn get_name(&self) -> Result<String, Self::Err>;
    fn get_alias(&self) -> Result<String, Self::Err>;
    fn set_alias(&self, value: String) -> Result<(), Self::Err>;
    fn get_class(&self) -> Result<u32, Self::Err>;
    fn get_powered(&self) -> Result<bool, Self::Err>;
    fn set_powered(&self, value: bool) -> Result<(), Self::Err>;
    fn get_discoverable(&self) -> Result<bool, Self::Err>;
    fn set_discoverable(&self, value: bool) -> Result<(), Self::Err>;
    fn get_discoverable_timeout(&self) -> Result<u32, Self::Err>;
    fn set_discoverable_timeout(&self, value: u32) -> Result<(), Self::Err>;
    fn get_pairable(&self) -> Result<bool, Self::Err>;
    fn set_pairable(&self, value: bool) -> Result<(), Self::Err>;
    fn get_pairable_timeout(&self) -> Result<u32, Self::Err>;
    fn set_pairable_timeout(&self, value: u32) -> Result<(), Self::Err>;
    fn get_discovering(&self) -> Result<bool, Self::Err>;
    fn get_uuids(&self) -> Result<Vec<String>, Self::Err>;
    fn get_modalias(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> Adapter1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn start_discovery(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Adapter1".into(), &"StartDiscovery".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn set_discovery_filter(&self, properties: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Adapter1".into(), &"SetDiscoveryFilter".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(properties);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn stop_discovery(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Adapter1".into(), &"StopDiscovery".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn remove_device(&self, device: dbus::Path) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Adapter1".into(), &"RemoveDevice".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(device);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn get_discovery_filters(&self) -> Result<Vec<String>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Adapter1".into(), &"GetDiscoveryFilters".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let filters: Vec<String> = i.read()?;
        Ok(filters)
    }

    fn get_address(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "Address")
    }

    fn get_address_type(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "AddressType")
    }

    fn get_name(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "Name")
    }

    fn get_alias(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "Alias")
    }

    fn get_class(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "Class")
    }

    fn get_powered(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "Powered")
    }

    fn get_discoverable(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "Discoverable")
    }

    fn get_discoverable_timeout(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "DiscoverableTimeout")
    }

    fn get_pairable(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "Pairable")
    }

    fn get_pairable_timeout(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "PairableTimeout")
    }

    fn get_discovering(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "Discovering")
    }

    fn get_uuids(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "UUIDs")
    }

    fn get_modalias(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Adapter1", "Modalias")
    }

    fn set_alias(&self, value: String) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.bluez.Adapter1", "Alias", value)
    }

    fn set_powered(&self, value: bool) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.bluez.Adapter1", "Powered", value)
    }

    fn set_discoverable(&self, value: bool) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.bluez.Adapter1", "Discoverable", value)
    }

    fn set_discoverable_timeout(&self, value: u32) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.bluez.Adapter1", "DiscoverableTimeout", value)
    }

    fn set_pairable(&self, value: bool) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.bluez.Adapter1", "Pairable", value)
    }

    fn set_pairable_timeout(&self, value: u32) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.bluez.Adapter1", "PairableTimeout", value)
    }
}

pub fn adapter1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: Adapter1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.Adapter1", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.start_discovery()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("StartDiscovery", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let properties: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        d.set_discovery_filter(properties)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetDiscoveryFilter", Default::default(), h);
    let m = m.in_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.stop_discovery()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("StopDiscovery", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let device: dbus::Path = i.read()?;
        let d = fclone(minfo);
        d.remove_device(device)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RemoveDevice", Default::default(), h);
    let m = m.in_arg(("device", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let filters = d.get_discovery_filters()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(filters);
        Ok(vec!(rm))
    };
    let m = factory.method("GetDiscoveryFilters", Default::default(), h);
    let m = m.out_arg(("filters", "as"));
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("Address", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_address()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("AddressType", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_address_type()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Name", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_name()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Alias", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_alias()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_alias(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("Class", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_class()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Powered", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_powered()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_powered(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Discoverable", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_discoverable()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_discoverable(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("DiscoverableTimeout", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_discoverable_timeout()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_discoverable_timeout(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Pairable", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_pairable()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_pairable(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("PairableTimeout", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_pairable_timeout()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_pairable_timeout(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Discovering", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_discovering()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("UUIDs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_uuids()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Modalias", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_modalias()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait LEAdvertisingManager1 {
    type Err;
    fn register_advertisement(&self, advertisement: dbus::Path, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err>;
    fn unregister_advertisement(&self, service: dbus::Path) -> Result<(), Self::Err>;
    fn get_active_instances(&self) -> Result<u8, Self::Err>;
    fn get_supported_instances(&self) -> Result<u8, Self::Err>;
    fn get_supported_includes(&self) -> Result<Vec<String>, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> LEAdvertisingManager1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn register_advertisement(&self, advertisement: dbus::Path, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.LEAdvertisingManager1".into(), &"RegisterAdvertisement".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(advertisement);
            i.append(options);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unregister_advertisement(&self, service: dbus::Path) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.LEAdvertisingManager1".into(), &"UnregisterAdvertisement".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(service);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn get_active_instances(&self) -> Result<u8, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.LEAdvertisingManager1", "ActiveInstances")
    }

    fn get_supported_instances(&self) -> Result<u8, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.LEAdvertisingManager1", "SupportedInstances")
    }

    fn get_supported_includes(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.LEAdvertisingManager1", "SupportedIncludes")
    }
}

pub fn leadvertising_manager1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: LEAdvertisingManager1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.LEAdvertisingManager1", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let advertisement: dbus::Path = i.read()?;
        let options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        d.register_advertisement(advertisement, options)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterAdvertisement", Default::default(), h);
    let m = m.in_arg(("advertisement", "o"));
    let m = m.in_arg(("options", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let service: dbus::Path = i.read()?;
        let d = fclone(minfo);
        d.unregister_advertisement(service)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnregisterAdvertisement", Default::default(), h);
    let m = m.in_arg(("service", "o"));
    let i = i.add_m(m);

    let p = factory.property::<u8, _>("ActiveInstances", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_active_instances()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u8, _>("SupportedInstances", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_supported_instances()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("SupportedIncludes", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_supported_includes()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait Media1 {
    type Err;
    fn register_endpoint(&self, endpoint: dbus::Path, properties: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err>;
    fn unregister_endpoint(&self, endpoint: dbus::Path) -> Result<(), Self::Err>;
    fn register_player(&self, player: dbus::Path, properties: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err>;
    fn unregister_player(&self, player: dbus::Path) -> Result<(), Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> Media1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn register_endpoint(&self, endpoint: dbus::Path, properties: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Media1".into(), &"RegisterEndpoint".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(endpoint);
            i.append(properties);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unregister_endpoint(&self, endpoint: dbus::Path) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Media1".into(), &"UnregisterEndpoint".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(endpoint);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn register_player(&self, player: dbus::Path, properties: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Media1".into(), &"RegisterPlayer".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(player);
            i.append(properties);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unregister_player(&self, player: dbus::Path) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Media1".into(), &"UnregisterPlayer".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(player);
        })?;
        m.as_result()?;
        Ok(())
    }
}

pub fn media1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: Media1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.Media1", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let endpoint: dbus::Path = i.read()?;
        let properties: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        d.register_endpoint(endpoint, properties)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterEndpoint", Default::default(), h);
    let m = m.in_arg(("endpoint", "o"));
    let m = m.in_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let endpoint: dbus::Path = i.read()?;
        let d = fclone(minfo);
        d.unregister_endpoint(endpoint)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnregisterEndpoint", Default::default(), h);
    let m = m.in_arg(("endpoint", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let player: dbus::Path = i.read()?;
        let properties: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        d.register_player(player, properties)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("RegisterPlayer", Default::default(), h);
    let m = m.in_arg(("player", "o"));
    let m = m.in_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let player: dbus::Path = i.read()?;
        let d = fclone(minfo);
        d.unregister_player(player)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnregisterPlayer", Default::default(), h);
    let m = m.in_arg(("player", "o"));
    let i = i.add_m(m);
    i
}

pub trait NetworkServer1 {
    type Err;
    fn register(&self, uuid: &str, bridge: &str) -> Result<(), Self::Err>;
    fn unregister(&self, uuid: &str) -> Result<(), Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> NetworkServer1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn register(&self, uuid: &str, bridge: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.NetworkServer1".into(), &"Register".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(uuid);
            i.append(bridge);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unregister(&self, uuid: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.NetworkServer1".into(), &"Unregister".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(uuid);
        })?;
        m.as_result()?;
        Ok(())
    }
}

pub fn network_server1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: NetworkServer1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.NetworkServer1", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let uuid: &str = i.read()?;
        let bridge: &str = i.read()?;
        let d = fclone(minfo);
        d.register(uuid, bridge)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Register", Default::default(), h);
    let m = m.in_arg(("uuid", "s"));
    let m = m.in_arg(("bridge", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let uuid: &str = i.read()?;
        let d = fclone(minfo);
        d.unregister(uuid)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Unregister", Default::default(), h);
    let m = m.in_arg(("uuid", "s"));
    let i = i.add_m(m);
    i
}

pub trait Device1 {
    type Err;
    fn disconnect(&self) -> Result<(), Self::Err>;
    fn connect(&self) -> Result<(), Self::Err>;
    fn connect_profile(&self, uuid: &str) -> Result<(), Self::Err>;
    fn disconnect_profile(&self, uuid: &str) -> Result<(), Self::Err>;
    fn pair(&self) -> Result<(), Self::Err>;
    fn cancel_pairing(&self) -> Result<(), Self::Err>;
    fn get_address(&self) -> Result<String, Self::Err>;
    fn get_address_type(&self) -> Result<String, Self::Err>;
    fn get_name(&self) -> Result<String, Self::Err>;
    fn get_alias(&self) -> Result<String, Self::Err>;
    fn set_alias(&self, value: String) -> Result<(), Self::Err>;
    fn get_class(&self) -> Result<u32, Self::Err>;
    fn get_appearance(&self) -> Result<u16, Self::Err>;
    fn get_icon(&self) -> Result<String, Self::Err>;
    fn get_paired(&self) -> Result<bool, Self::Err>;
    fn get_trusted(&self) -> Result<bool, Self::Err>;
    fn set_trusted(&self, value: bool) -> Result<(), Self::Err>;
    fn get_blocked(&self) -> Result<bool, Self::Err>;
    fn set_blocked(&self, value: bool) -> Result<(), Self::Err>;
    fn get_legacy_pairing(&self) -> Result<bool, Self::Err>;
    fn get_rssi(&self) -> Result<i16, Self::Err>;
    fn get_connected(&self) -> Result<bool, Self::Err>;
    fn get_uuids(&self) -> Result<Vec<String>, Self::Err>;
    fn get_modalias(&self) -> Result<String, Self::Err>;
    fn get_adapter(&self) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_manufacturer_data(&self) -> Result<::std::collections::HashMap<u16, arg::Variant<Box<arg::RefArg + 'static>>>, Self::Err>;
    fn get_service_data(&self) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>, Self::Err>;
    fn get_tx_power(&self) -> Result<i16, Self::Err>;
    fn get_services_resolved(&self) -> Result<bool, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> Device1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn disconnect(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Device1".into(), &"Disconnect".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn connect(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Device1".into(), &"Connect".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn connect_profile(&self, uuid: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Device1".into(), &"ConnectProfile".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(uuid);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn disconnect_profile(&self, uuid: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Device1".into(), &"DisconnectProfile".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(uuid);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn pair(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Device1".into(), &"Pair".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn cancel_pairing(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.Device1".into(), &"CancelPairing".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn get_address(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Address")
    }

    fn get_address_type(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "AddressType")
    }

    fn get_name(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Name")
    }

    fn get_alias(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Alias")
    }

    fn get_class(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Class")
    }

    fn get_appearance(&self) -> Result<u16, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Appearance")
    }

    fn get_icon(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Icon")
    }

    fn get_paired(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Paired")
    }

    fn get_trusted(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Trusted")
    }

    fn get_blocked(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Blocked")
    }

    fn get_legacy_pairing(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "LegacyPairing")
    }

    fn get_rssi(&self) -> Result<i16, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "RSSI")
    }

    fn get_connected(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Connected")
    }

    fn get_uuids(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "UUIDs")
    }

    fn get_modalias(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Modalias")
    }

    fn get_adapter(&self) -> Result<dbus::Path<'static>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "Adapter")
    }

    fn get_manufacturer_data(&self) -> Result<::std::collections::HashMap<u16, arg::Variant<Box<arg::RefArg + 'static>>>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "ManufacturerData")
    }

    fn get_service_data(&self) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "ServiceData")
    }

    fn get_tx_power(&self) -> Result<i16, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "TxPower")
    }

    fn get_services_resolved(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.Device1", "ServicesResolved")
    }

    fn set_alias(&self, value: String) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.bluez.Device1", "Alias", value)
    }

    fn set_trusted(&self, value: bool) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.bluez.Device1", "Trusted", value)
    }

    fn set_blocked(&self, value: bool) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.bluez.Device1", "Blocked", value)
    }
}

pub fn device1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: Device1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.Device1", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.disconnect()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Disconnect", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.connect()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Connect", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let uuid: &str = i.read()?;
        let d = fclone(minfo);
        d.connect_profile(uuid)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ConnectProfile", Default::default(), h);
    let m = m.in_arg(("UUID", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let uuid: &str = i.read()?;
        let d = fclone(minfo);
        d.disconnect_profile(uuid)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("DisconnectProfile", Default::default(), h);
    let m = m.in_arg(("UUID", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.pair()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Pair", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.cancel_pairing()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("CancelPairing", Default::default(), h);
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("Address", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_address()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("AddressType", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_address_type()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Name", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_name()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Alias", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_alias()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_alias(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("Class", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_class()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u16, _>("Appearance", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_appearance()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Icon", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_icon()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Paired", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_paired()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Trusted", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_trusted()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_trusted(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Blocked", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_blocked()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_blocked(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("LegacyPairing", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_legacy_pairing()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i16, _>("RSSI", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_rssi()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Connected", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_connected()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("UUIDs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_uuids()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Modalias", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_modalias()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<dbus::Path, _>("Adapter", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_adapter()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<::std::collections::HashMap<u16, arg::Variant<Box<arg::RefArg>>>, _>("ManufacturerData", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_manufacturer_data()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>, _>("ServiceData", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_service_data()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<i16, _>("TxPower", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_tx_power()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("ServicesResolved", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_services_resolved()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait GattService1 {
    type Err;
    fn get_uuid(&self) -> Result<String, Self::Err>;
    fn get_device(&self) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_primary(&self) -> Result<bool, Self::Err>;
    fn get_includes(&self) -> Result<Vec<dbus::Path<'static>>, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> GattService1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get_uuid(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattService1", "UUID")
    }

    fn get_device(&self) -> Result<dbus::Path<'static>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattService1", "Device")
    }

    fn get_primary(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattService1", "Primary")
    }

    fn get_includes(&self) -> Result<Vec<dbus::Path<'static>>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattService1", "Includes")
    }
}

pub fn gatt_service1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: GattService1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.GattService1", data);
    let f = ::std::sync::Arc::new(f);
    let p = factory.property::<&str, _>("UUID", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_uuid()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<dbus::Path, _>("Device", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_device()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Primary", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_primary()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<dbus::Path>, _>("Includes", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_includes()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait GattCharacteristic1 {
    type Err;
    fn read_value(&self, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<Vec<u8>, Self::Err>;
    fn write_value(&self, value: Vec<u8>, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err>;
    fn acquire_write(&self, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(dbus::OwnedFd, u16), Self::Err>;
    fn acquire_notify(&self, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(dbus::OwnedFd, u16), Self::Err>;
    fn start_notify(&self) -> Result<(), Self::Err>;
    fn stop_notify(&self) -> Result<(), Self::Err>;
    fn get_uuid(&self) -> Result<String, Self::Err>;
    fn get_service(&self) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_value(&self) -> Result<Vec<u8>, Self::Err>;
    fn get_notifying(&self) -> Result<bool, Self::Err>;
    fn get_flags(&self) -> Result<Vec<String>, Self::Err>;
    fn get_write_acquired(&self) -> Result<bool, Self::Err>;
    fn get_notify_acquired(&self) -> Result<bool, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> GattCharacteristic1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn read_value(&self, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<Vec<u8>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.GattCharacteristic1".into(), &"ReadValue".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(options);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let value: Vec<u8> = i.read()?;
        Ok(value)
    }

    fn write_value(&self, value: Vec<u8>, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.GattCharacteristic1".into(), &"WriteValue".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(value);
            i.append(options);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn acquire_write(&self, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(dbus::OwnedFd, u16), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.GattCharacteristic1".into(), &"AcquireWrite".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(options);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let fd: dbus::OwnedFd = i.read()?;
        let mtu: u16 = i.read()?;
        Ok((fd, mtu))
    }

    fn acquire_notify(&self, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(dbus::OwnedFd, u16), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.GattCharacteristic1".into(), &"AcquireNotify".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(options);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let fd: dbus::OwnedFd = i.read()?;
        let mtu: u16 = i.read()?;
        Ok((fd, mtu))
    }

    fn start_notify(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.GattCharacteristic1".into(), &"StartNotify".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn stop_notify(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.GattCharacteristic1".into(), &"StopNotify".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn get_uuid(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattCharacteristic1", "UUID")
    }

    fn get_service(&self) -> Result<dbus::Path<'static>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattCharacteristic1", "Service")
    }

    fn get_value(&self) -> Result<Vec<u8>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattCharacteristic1", "Value")
    }

    fn get_notifying(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattCharacteristic1", "Notifying")
    }

    fn get_flags(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattCharacteristic1", "Flags")
    }

    fn get_write_acquired(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattCharacteristic1", "WriteAcquired")
    }

    fn get_notify_acquired(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattCharacteristic1", "NotifyAcquired")
    }
}

pub fn gatt_characteristic1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: GattCharacteristic1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.GattCharacteristic1", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        let value = d.read_value(options)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(value);
        Ok(vec!(rm))
    };
    let m = factory.method("ReadValue", Default::default(), h);
    let m = m.in_arg(("options", "a{sv}"));
    let m = m.out_arg(("value", "ay"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let value: Vec<u8> = i.read()?;
        let options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        d.write_value(value, options)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("WriteValue", Default::default(), h);
    let m = m.in_arg(("value", "ay"));
    let m = m.in_arg(("options", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        let (fd, mtu) = d.acquire_write(options)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(fd);
        let rm = rm.append1(mtu);
        Ok(vec!(rm))
    };
    let m = factory.method("AcquireWrite", Default::default(), h);
    let m = m.in_arg(("options", "a{sv}"));
    let m = m.out_arg(("fd", "h"));
    let m = m.out_arg(("mtu", "q"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        let (fd, mtu) = d.acquire_notify(options)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(fd);
        let rm = rm.append1(mtu);
        Ok(vec!(rm))
    };
    let m = factory.method("AcquireNotify", Default::default(), h);
    let m = m.in_arg(("options", "a{sv}"));
    let m = m.out_arg(("fd", "h"));
    let m = m.out_arg(("mtu", "q"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.start_notify()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("StartNotify", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.stop_notify()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("StopNotify", Default::default(), h);
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("UUID", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_uuid()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<dbus::Path, _>("Service", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_service()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<u8>, _>("Value", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_value()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Notifying", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_notifying()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("Flags", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_flags()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("WriteAcquired", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_write_acquired()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("NotifyAcquired", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_notify_acquired()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait GattDescriptor1 {
    type Err;
    fn read_value(&self, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<Vec<u8>, Self::Err>;
    fn write_value(&self, value: Vec<u8>, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err>;
    fn get_uuid(&self) -> Result<String, Self::Err>;
    fn get_characteristic(&self) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_value(&self) -> Result<Vec<u8>, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> GattDescriptor1 for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn read_value(&self, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<Vec<u8>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.GattDescriptor1".into(), &"ReadValue".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(options);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let value: Vec<u8> = i.read()?;
        Ok(value)
    }

    fn write_value(&self, value: Vec<u8>, options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.bluez.GattDescriptor1".into(), &"WriteValue".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(value);
            i.append(options);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn get_uuid(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattDescriptor1", "UUID")
    }

    fn get_characteristic(&self) -> Result<dbus::Path<'static>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattDescriptor1", "Characteristic")
    }

    fn get_value(&self) -> Result<Vec<u8>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.bluez.GattDescriptor1", "Value")
    }
}

pub fn gatt_descriptor1_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: GattDescriptor1<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.bluez.GattDescriptor1", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        let value = d.read_value(options)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(value);
        Ok(vec!(rm))
    };
    let m = factory.method("ReadValue", Default::default(), h);
    let m = m.in_arg(("options", "a{sv}"));
    let m = m.out_arg(("value", "ay"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let value: Vec<u8> = i.read()?;
        let options: ::std::collections::HashMap<&str, arg::Variant<Box<arg::RefArg>>> = i.read()?;
        let d = fclone(minfo);
        d.write_value(value, options)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("WriteValue", Default::default(), h);
    let m = m.in_arg(("value", "ay"));
    let m = m.in_arg(("options", "a{sv}"));
    let i = i.add_m(m);

    let p = factory.property::<&str, _>("UUID", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_uuid()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<dbus::Path, _>("Characteristic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_characteristic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<u8>, _>("Value", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_value()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}
